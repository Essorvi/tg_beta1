from fastapi import FastAPI, APIRouter, HTTPException, Request, Query
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
import requests
import json
import hashlib
import secrets
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
import uuid
import re

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# API Configuration
TELEGRAM_TOKEN = os.environ['TELEGRAM_TOKEN']
WEBHOOK_SECRET = os.environ['WEBHOOK_SECRET']
USERSBOX_TOKEN = os.environ['USERSBOX_TOKEN']
USERSBOX_BASE_URL = os.environ['USERSBOX_BASE_URL']
ADMIN_USERNAME = os.environ['ADMIN_USERNAME']
REQUIRED_CHANNEL = os.environ['REQUIRED_CHANNEL']
BOT_USERNAME = os.environ.get('BOT_USERNAME', 'search1_test_bot')

# Create the main app
app = FastAPI(title="–£–ó–†–ò - Telegram Bot API")

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# Models
class User(BaseModel):
    telegram_id: int
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    balance: float = 0.0  # –ë–∞–ª–∞–Ω—Å –≤ —Ä—É–±–ª—è—Ö
    subscription_type: Optional[str] = None  # "day", "3days", "month", None
    subscription_expires: Optional[datetime] = None
    daily_searches_used: int = 0  # –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∏ –∑–∞ –¥–µ–Ω—å
    daily_searches_reset: datetime = Field(default_factory=datetime.utcnow)
    referred_by: Optional[int] = None
    referral_code: str
    total_referrals: int = 0
    created_at: datetime = Field(default_factory=datetime.utcnow)
    is_admin: bool = False
    last_active: datetime = Field(default_factory=datetime.utcnow)
    is_subscribed: bool = False

class Subscription(BaseModel):
    user_id: int
    subscription_type: str  # "day", "3days", "month"
    price: float
    started_at: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime
    max_daily_searches: int = 12

class Payment(BaseModel):
    user_id: int
    amount: float
    payment_type: str  # "crypto", "stars", "admin"
    payment_id: Optional[str] = None
    status: str = "pending"  # "pending", "completed", "failed"
    created_at: datetime = Field(default_factory=datetime.utcnow)

class Search(BaseModel):
    user_id: int
    query: str
    search_type: str
    results: Dict[str, Any]
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    cost: float = 25.0
    success: bool = True
    payment_method: str = "balance"  # "balance", "subscription"

class Referral(BaseModel):
    referrer_id: int
    referred_id: int
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    confirmed: bool = False  # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω –ª–∏ —Ä–µ—Ñ–µ—Ä–∞–ª (–ø–æ–¥–ø–∏—Å–∞–ª—Å—è –ª–∏ –Ω–∞ –∫–∞–Ω–∞–ª)

# Helper Functions
def generate_referral_code(telegram_id: int) -> str:
    """Generate unique referral code"""
    data = f"{telegram_id}_{secrets.token_hex(8)}"
    return hashlib.md5(data.encode()).hexdigest()[:8]

def detect_search_type(query: str) -> str:
    """Detect search type based on query pattern"""
    query = query.strip()
    
    phone_patterns = [
        r'^\+?[7-8]\d{10}$',
        r'^\+?\d{10,15}$',
        r'^[7-8]\(\d{3}\)\d{3}-?\d{2}-?\d{2}$'
    ]
    
    for pattern in phone_patterns:
        if re.match(pattern, query.replace(' ', '').replace('-', '').replace('(', '').replace(')', '')):
            return "üì± –¢–µ–ª–µ—Ñ–æ–Ω"
    
    if re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', query):
        return "üìß Email"
    
    if re.match(r'^[–ê–í–ï–ö–ú–ù–û–†–°–¢–£–•]\d{3}[–ê–í–ï–ö–ú–ù–û–†–°–¢–£–•]{2}\d{2,3}$', query.upper().replace(' ', '')):
        return "üöó –ê–≤—Ç–æ–º–æ–±–∏–ª—å"
    
    if query.startswith('@') or re.match(r'^[a-zA-Z0-9_]+$', query):
        return "üÜî –ù–∏–∫–Ω–µ–π–º"
    
    if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', query):
        return "üåê IP-–∞–¥—Ä–µ—Å"
    
    address_keywords = ['—É–ª–∏—Ü–∞', '—É–ª', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä', '–ø–µ—Ä–µ—É–ª–æ–∫', '–ø–µ—Ä', '–¥–æ–º', '–¥', '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤']
    if any(keyword in query.lower() for keyword in address_keywords):
        return "üè† –ê–¥—Ä–µ—Å"
    
    words = query.split()
    if 2 <= len(words) <= 3 and all(re.match(r'^[–∞-—è–ê-–Ø—ë–Åa-zA-Z]+$', word) for word in words):
        return "üë§ –§–ò–û"
    
    return "üîç –û–±—â–∏–π –ø–æ–∏—Å–∫"

def create_main_menu():
    """Create main menu keyboard"""
    return {
        "inline_keyboard": [
            [
                {"text": "üîç –ü–æ–∏—Å–∫", "callback_data": "menu_search"},
                {"text": "üë§ –ü—Ä–æ—Ñ–∏–ª—å", "callback_data": "menu_profile"}
            ],
            [
                {"text": "üí∞ –ë–∞–ª–∞–Ω—Å", "callback_data": "menu_balance"},
                {"text": "üõí –¢–∞—Ä–∏—Ñ—ã", "callback_data": "menu_pricing"}
            ],
            [
                {"text": "üîó –†–µ—Ñ–µ—Ä–∞–ª—ã", "callback_data": "menu_referral"},
                {"text": "‚ùì –ü–æ–º–æ—â—å", "callback_data": "menu_help"}
            ],
            [
                {"text": "üìã –ü—Ä–∞–≤–∏–ª–∞", "callback_data": "menu_rules"}
            ]
        ]
    }

def create_admin_menu():
    """Create admin menu keyboard"""
    return {
        "inline_keyboard": [
            [
                {"text": "üíé –ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å", "callback_data": "admin_add_balance"},
                {"text": "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", "callback_data": "admin_stats"}
            ],
            [
                {"text": "üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", "callback_data": "admin_users"},
                {"text": "üí≥ –ü–ª–∞—Ç–µ–∂–∏", "callback_data": "admin_payments"}
            ],
            [
                {"text": "‚óÄÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "callback_data": "back_to_menu"}
            ]
        ]
    }

def create_balance_menu():
    """Create balance menu keyboard"""
    return {
        "inline_keyboard": [
            [
                {"text": "ü§ñ –ö—Ä–∏–ø—Ç–æ–±–æ—Ç", "callback_data": "pay_crypto"},
                {"text": "‚≠ê –ó–≤–µ–∑–¥—ã", "callback_data": "pay_stars"}
            ],
            [
                {"text": "üõí –ö—É–ø–∏—Ç—å 1 –ø–æ–∏—Å–∫ (25‚ÇΩ)", "callback_data": "buy_single_search"}
            ],
            [
                {"text": "‚óÄÔ∏è –ù–∞–∑–∞–¥", "callback_data": "back_to_menu"}
            ]
        ]
    }

def create_pricing_menu():
    """Create pricing menu keyboard"""
    return {
        "inline_keyboard": [
            [
                {"text": "üìÖ 1 –¥–µ–Ω—å (149‚ÇΩ)", "callback_data": "buy_day_sub"},
                {"text": "üìÖ 3 –¥–Ω—è (299‚ÇΩ)", "callback_data": "buy_3days_sub"}
            ],
            [
                {"text": "üìÖ 1 –º–µ—Å—è—Ü (1700‚ÇΩ)", "callback_data": "buy_month_sub"}
            ],
            [
                {"text": "‚óÄÔ∏è –ù–∞–∑–∞–¥", "callback_data": "back_to_menu"}
            ]
        ]
    }

def create_back_keyboard():
    """Create back button keyboard"""
    return {
        "inline_keyboard": [
            [{"text": "‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", "callback_data": "back_to_menu"}]
        ]
    }

def create_subscription_keyboard():
    """Create subscription check keyboard"""
    return {
        "inline_keyboard": [
            [
                {"text": "üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª", "url": "https://t.me/uzri_sebya"}
            ],
            [
                {"text": "‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", "callback_data": "check_subscription"}
            ]
        ]
    }

async def check_daily_limit_reset(user: User) -> User:
    """Check if daily search limit should be reset"""
    now = datetime.utcnow()
    if now.date() > user.daily_searches_reset.date():
        await db.users.update_one(
            {"telegram_id": user.telegram_id},
            {
                "$set": {
                    "daily_searches_used": 0,
                    "daily_searches_reset": now
                }
            }
        )
        user.daily_searches_used = 0
        user.daily_searches_reset = now
    return user

async def has_active_subscription(user: User) -> bool:
    """Check if user has active subscription"""
    if not user.subscription_expires:
        return False
    return datetime.utcnow() < user.subscription_expires

async def can_search(user: User) -> tuple[bool, str]:
    """Check if user can perform search"""
    # Admin always can search
    if user.is_admin:
        return True, ""
    
    # Check subscription first
    if await has_active_subscription(user):
        user = await check_daily_limit_reset(user)
        if user.daily_searches_used >= 12:
            return False, "–ø—Ä–µ–≤—ã—à–µ–Ω –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –ø–æ–¥–ø–∏—Å–∫–∏ (12 –ø–æ–∏—Å–∫–æ–≤)"
        return True, "subscription"
    
    # Check balance for single search
    if user.balance >= 25.0:
        return True, "balance"
    
    return False, "–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤"

async def usersbox_request(endpoint: str, params: Dict = None) -> Dict:
    """Make request to usersbox API"""
    headers = {"Authorization": USERSBOX_TOKEN}
    url = f"{USERSBOX_BASE_URL}{endpoint}"
    
    try:
        response = requests.get(url, headers=headers, params=params or {}, timeout=30)
        return response.json()
    except Exception as e:
        logging.error(f"Usersbox API error: {e}")
        return {"status": "error", "error": {"message": str(e)}}

def format_search_results(results: Dict[str, Any], query: str, search_type: str) -> str:
    """Format usersbox API results for Telegram"""
    if results.get('status') == 'error':
        return f"‚ùå *–û—à–∏–±–∫–∞:* {results.get('error', {}).get('message', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}"

    data = results.get('data', {})
    total_count = data.get('count', 0)
    
    if total_count == 0:
        return f"üîç *–ü–æ–∏—Å–∫:* `{query}`\n{search_type}\n\n‚ùå *–†–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ*\n\nüí° *–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞*"
    
    formatted_text = f"üéØ *–†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û–ò–°–ö–ê*\n\n"
    formatted_text += f"üîç *–ó–∞–ø—Ä–æ—Å:* `{query}`\n"
    formatted_text += f"üìÇ *–¢–∏–ø:* {search_type}\n"
    formatted_text += f"üìä *–ù–∞–π–¥–µ–Ω–æ:* {total_count} –∑–∞–ø–∏—Å–µ–π\n\n"

    if 'items' in data and isinstance(data['items'], list):
        formatted_text += "üìã *–î–ê–ù–ù–´–ï –ò–ó –ë–ê–ó:*\n\n"
        
        for i, source_data in enumerate(data['items'][:5], 1):
            if 'source' in source_data and 'hits' in source_data:
                source = source_data['source']
                hits = source_data['hits']
                hits_count = hits.get('hitsCount', hits.get('count', 0))
                
                db_names = {
                    'yandex': 'üü° –Ø–Ω–¥–µ–∫—Å',
                    'avito': 'üü¢ –ê–≤–∏—Ç–æ',
                    'vk': 'üîµ –í–ö–æ–Ω—Ç–∞–∫—Ç–µ',
                    'ok': 'üü† –û–¥–Ω–æ–∫–ª–∞—Å—Å–Ω–∏–∫–∏',
                    'delivery_club': 'üçï Delivery Club',
                    'cdek': 'üì¶ –°–î–≠–ö'
                }
                
                db_display = db_names.get(source.get('database', ''), f"üìä {source.get('database', 'N/A')}")
                
                formatted_text += f"*{i}. {db_display}*\n"
                formatted_text += f"üìÅ –ë–∞–∑–∞: {source.get('collection', 'N/A')}\n"
                formatted_text += f"üî¢ –ó–∞–ø–∏—Å–µ–π: {hits_count}\n"

                if 'items' in hits and hits['items']:
                    formatted_text += "üíæ *–î–∞–Ω–Ω—ã–µ:*\n"
                    for item in hits['items'][:2]:
                        for key, value in item.items():
                            if key.startswith('_'):
                                continue
                            
                            if key in ['phone', '—Ç–µ–ª–µ—Ñ–æ–Ω', 'tel', 'mobile']:
                                formatted_text += f"üìû {value}\n"
                            elif key in ['email', '–ø–æ—á—Ç–∞', 'mail', 'e_mail']:
                                formatted_text += f"üìß {value}\n"
                            elif key in ['full_name', 'name', '–∏–º—è', '—Ñ–∏–æ', 'first_name', 'last_name']:
                                formatted_text += f"üë§ {value}\n"
                            elif key in ['birth_date', 'birthday', '–¥–∞—Ç–∞_—Ä–æ–∂–¥–µ–Ω–∏—è', 'bdate']:
                                formatted_text += f"üéÇ {value}\n"
                            elif key in ['address', '–∞–¥—Ä–µ—Å', 'city', '–≥–æ—Ä–æ–¥']:
                                formatted_text += f"üè† {value}\n"
                            elif key in ['sex', 'gender', '–ø–æ–ª']:
                                gender_map = {'1': '–ñ', '2': '–ú', 'male': '–ú', 'female': '–ñ'}
                                formatted_text += f"‚ö• {gender_map.get(str(value), value)}\n"
                
                formatted_text += "\n"

    formatted_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    formatted_text += "üîí *–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å:* –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ"
    
    return formatted_text

async def check_subscription(user_id: int) -> bool:
    """Check if user is subscribed to required channel"""
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getChatMember"
        params = {
            "chat_id": REQUIRED_CHANNEL,
            "user_id": user_id
        }
        
        response = requests.get(url, params=params, timeout=10)
        if response.status_code == 200:
            data = response.json()
            if data.get('ok'):
                status = data.get('result', {}).get('status')
                return status in ['member', 'administrator', 'creator']
        
        return False
    except Exception as e:
        logging.error(f"Subscription check error: {e}")
        return False

async def send_telegram_message(chat_id: int, text: str, parse_mode: str = "Markdown", reply_markup: dict = None) -> bool:
    """Send message to Telegram user"""
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": text,
        "parse_mode": parse_mode
    }
    
    if reply_markup:
        payload["reply_markup"] = reply_markup
    
    try:
        response = requests.post(url, json=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        logging.error(f"Failed to send Telegram message: {e}")
        return False

async def get_or_create_user(telegram_id: int, username: str = None, first_name: str = None, last_name: str = None) -> User:
    """Get existing user or create new one"""
    user_data = await db.users.find_one({"telegram_id": telegram_id})
    
    if user_data:
        await db.users.update_one(
            {"telegram_id": telegram_id},
            {
                "$set": {
                    "last_active": datetime.utcnow(),
                    "username": username,
                    "first_name": first_name,
                    "last_name": last_name
                }
            }
        )
        return User(**user_data)
    else:
        referral_code = generate_referral_code(telegram_id)
        is_admin = username == ADMIN_USERNAME if username else False
        
        user = User(
            telegram_id=telegram_id,
            username=username,
            first_name=first_name,
            last_name=last_name,
            referral_code=referral_code,
            is_admin=is_admin,
            balance=0.0  # –ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –±–µ–∑ –¥–µ–Ω–µ–≥
        )
        
        await db.users.insert_one(user.dict())
        return user

# API Routes
@api_router.get("/")
async def root():
    return {"message": "–£–ó–†–ò - Telegram Bot API", "status": "running"}

@api_router.post("/webhook/{secret}")
async def telegram_webhook(secret: str, request: Request):
    """Handle Telegram webhook"""
    if secret != WEBHOOK_SECRET:
        raise HTTPException(status_code=403, detail="Invalid webhook secret")
    
    try:
        update_data = await request.json()
        await handle_telegram_update(update_data)
        return {"status": "ok"}
    except Exception as e:
        logging.error(f"Webhook processing failed: {e}")
        raise HTTPException(status_code=500, detail=f"Webhook processing failed: {str(e)}")

async def handle_callback_query(callback_query: Dict[str, Any]):
    """Handle callback queries from inline keyboard buttons"""
    chat_id = callback_query.get('message', {}).get('chat', {}).get('id')
    user_id = callback_query.get('from', {}).get('id')
    data = callback_query.get('data')
    callback_query_id = callback_query.get('id')
    
    # Answer callback query
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/answerCallbackQuery"
        requests.post(url, json={"callback_query_id": callback_query_id}, timeout=5)
    except:
        pass
    
    user = await get_or_create_user(
        telegram_id=user_id,
        username=callback_query.get('from', {}).get('username'),
        first_name=callback_query.get('from', {}).get('first_name'),
        last_name=callback_query.get('from', {}).get('last_name')
    )
    
    # Handle different callback data
    if data == "check_subscription":
        await handle_subscription_check(chat_id, user_id)
    elif data == "back_to_menu":
        await show_main_menu(chat_id, user)
    elif data == "menu_search":
        await show_search_menu(chat_id, user)
    elif data == "menu_profile":
        await show_profile_menu(chat_id, user)
    elif data == "menu_balance":
        await show_balance_menu(chat_id, user)
    elif data == "menu_pricing":
        await show_pricing_menu(chat_id, user)
    elif data == "menu_referral":
        await show_referral_menu(chat_id, user)
    elif data == "menu_help":
        await show_help_menu(chat_id, user)
    elif data == "menu_rules":
        await show_rules_menu(chat_id, user)
    elif data.startswith("admin_") and user.is_admin:
        await handle_admin_callback(chat_id, user, data)
    elif data.startswith("pay_"):
        await handle_payment_callback(chat_id, user, data)
    elif data.startswith("buy_"):
        await handle_purchase_callback(chat_id, user, data)

async def handle_subscription_check(chat_id: int, user_id: int):
    """Handle subscription check"""
    is_subscribed = await check_subscription(user_id)
    if is_subscribed:
        await db.users.update_one(
            {"telegram_id": user_id},
            {"$set": {"is_subscribed": True}}
        )
        
        # Confirm referral if exists
        await confirm_referral(user_id)
        
        await send_telegram_message(
            chat_id,
            "‚úÖ *–ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!*\n\nüéâ –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–µ—Ä–≤–∏—Å–æ–º!"
        )
    else:
        await send_telegram_message(
            chat_id,
            "‚ùå *–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞*\n\nüì¢ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @uzri_sebya –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞",
            reply_markup=create_subscription_keyboard()
        )

async def confirm_referral(user_id: int):
    """Confirm referral when user subscribes to channel"""
    referral = await db.referrals.find_one({"referred_id": user_id, "confirmed": False})
    if referral:
        # Mark referral as confirmed
        await db.referrals.update_one(
            {"_id": referral["_id"]},
            {"$set": {"confirmed": True}}
        )
        
        # Give 25‚ÇΩ to referrer (1 search attempt)
        await db.users.update_one(
            {"telegram_id": referral["referrer_id"]},
            {"$inc": {"balance": 25.0}}
        )
        
        # Notify referrer
        await send_telegram_message(
            referral["referrer_id"],
            f"üéâ *–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª!*\n\nüí∞ –ù–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å –∑–∞—á–∏—Å–ª–µ–Ω–æ 25‚ÇΩ\n(1 –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–∏—Å–∫–∞)"
        )

async def show_main_menu(chat_id: int, user: User):
    """Show main menu"""
    welcome_text = f"üéØ *–°–ï–†–í–ò–° - –£–ó–†–ò*\n\n"
    welcome_text += f"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {user.first_name or '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'}!\n\n"
    
    # Show subscription status
    if await has_active_subscription(user):
        expires = user.subscription_expires.strftime('%d.%m.%Y %H:%M')
        welcome_text += f"‚úÖ *–ü–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ:* {expires}\n"
        user = await check_daily_limit_reset(user)
        welcome_text += f"üîç *–ü–æ–∏—Å–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è:* {user.daily_searches_used}/12\n\n"
    else:
        welcome_text += f"üí∞ *–ë–∞–ª–∞–Ω—Å:* {user.balance:.2f} ‚ÇΩ\n"
        searches_available = int(user.balance // 25)
        welcome_text += f"üîç *–î–æ—Å—Ç—É–ø–Ω–æ –ø–æ–∏—Å–∫–æ–≤:* {searches_available}\n\n"
    
    welcome_text += f"üë• *–†–µ—Ñ–µ—Ä–∞–ª–æ–≤:* {user.total_referrals}\n\n"
    welcome_text += f"üîç *–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:*"
    
    if user.is_admin:
        # Show admin menu for eriksson_sop
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "üîç –ü–æ–∏—Å–∫", "callback_data": "menu_search"},
                    {"text": "üë§ –ü—Ä–æ—Ñ–∏–ª—å", "callback_data": "menu_profile"}
                ],
                [
                    {"text": "üí∞ –ë–∞–ª–∞–Ω—Å", "callback_data": "menu_balance"},
                    {"text": "üõí –¢–∞—Ä–∏—Ñ—ã", "callback_data": "menu_pricing"}
                ],
                [
                    {"text": "üîó –†–µ—Ñ–µ—Ä–∞–ª—ã", "callback_data": "menu_referral"},
                    {"text": "‚ùì –ü–æ–º–æ—â—å", "callback_data": "menu_help"}
                ],
                [
                    {"text": "üìã –ü—Ä–∞–≤–∏–ª–∞", "callback_data": "menu_rules"}
                ],
                [
                    {"text": "üëë –ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨", "callback_data": "admin_panel"}
                ]
            ]
        }
    else:
        keyboard = create_main_menu()
    
    await send_telegram_message(chat_id, welcome_text, reply_markup=keyboard)

async def show_search_menu(chat_id: int, user: User):
    """Show search menu"""
    if not user.is_admin:
        is_subscribed = await check_subscription(user.telegram_id)
        if not is_subscribed:
            await send_telegram_message(
                chat_id,
                "üîí *–î–ª—è –ø–æ–∏—Å–∫–∞ –Ω—É–∂–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞!*\n\nüì¢ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ @uzri_sebya",
                reply_markup=create_subscription_keyboard()
            )
            return
    
    can_search_result, payment_method = await can_search(user)
    
    if not can_search_result and not user.is_admin:
        if "–ø—Ä–µ–≤—ã—à–µ–Ω –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç" in payment_method:
            search_text = f"‚è∞ *–î–ù–ï–í–ù–û–ô –õ–ò–ú–ò–¢ –ò–°–ß–ï–†–ü–ê–ù*\n\n"
            search_text += f"üìÖ –í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 12 –ø–æ–∏—Å–∫–æ–≤ –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è\n"
            search_text += f"üïí –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≤—Ç—Ä–∞ –∏–ª–∏ –∫—É–ø–∏—Ç–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ø–æ–∏—Å–∫–∏"
        else:
            search_text = f"üí∞ *–ù–ï–î–û–°–¢–ê–¢–û–ß–ù–û –°–†–ï–î–°–¢–í*\n\n"
            search_text += f"üí≥ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance:.2f} ‚ÇΩ\n"
            search_text += f"üíé –ù—É–∂–Ω–æ: 25 ‚ÇΩ –∑–∞ –ø–æ–∏—Å–∫\n\n"
            search_text += f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –∏–ª–∏ –æ—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É"
        
        await send_telegram_message(chat_id, search_text, reply_markup=create_back_keyboard())
        return
    
    search_text = f"üîç *–ü–û–ò–°–ö –ü–û –ë–ê–ó–ê–ú –î–ê–ù–ù–´–•*\n\n"
    
    if user.is_admin:
        search_text += f"üëë *–†–µ–∂–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞*\n"
    elif await has_active_subscription(user):
        user = await check_daily_limit_reset(user)
        search_text += f"‚úÖ *–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞*\n"
        search_text += f"üîç *–ü–æ–∏—Å–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è:* {user.daily_searches_used}/12\n"
    else:
        search_text += f"üí∞ *–ë–∞–ª–∞–Ω—Å:* {user.balance:.2f} ‚ÇΩ\n"
        searches_available = int(user.balance // 25)
        search_text += f"üîç *–î–æ—Å—Ç—É–ø–Ω–æ –ø–æ–∏—Å–∫–æ–≤:* {searches_available}\n"
    
    search_text += f"\nüìù *–ß—Ç–æ –º–æ–∂–Ω–æ –∏—Å–∫–∞—Ç—å:*\n"
    search_text += f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: +79123456789\n"
    search_text += f"üìß Email: user@mail.ru\n"
    search_text += f"üë§ –§–ò–û: –ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤\n"
    search_text += f"üöó –ê–≤—Ç–æ: –ê123–í–°777\n"
    search_text += f"üÜî –ù–∏–∫–Ω–µ–π–º: @username\n\n"
    search_text += f"‚û°Ô∏è *–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–∏—Å–∫–∞*"
    
    await send_telegram_message(chat_id, search_text, reply_markup=create_back_keyboard())

async def show_profile_menu(chat_id: int, user: User):
    """Show profile menu"""
    total_searches = await db.searches.count_documents({"user_id": user.telegram_id})
    successful_searches = await db.searches.count_documents({"user_id": user.telegram_id, "success": True})
    
    profile_text = f"üë§ *–í–ê–® –ü–†–û–§–ò–õ–¨*\n\n"
    profile_text += f"üÜî *ID:* `{user.telegram_id}`\n"
    profile_text += f"üë§ *–ò–º—è:* {user.first_name or 'N/A'}\n"
    profile_text += f"üîó *Username:* @{user.username or 'N/A'}\n\n"
    
    profile_text += f"üí∞ *–§–ò–ù–ê–ù–°–´:*\n"
    profile_text += f"üí≥ –ë–∞–ª–∞–Ω—Å: {user.balance:.2f} ‚ÇΩ\n"
    
    if await has_active_subscription(user):
        sub_type_names = {"day": "1 –¥–µ–Ω—å", "3days": "3 –¥–Ω—è", "month": "1 –º–µ—Å—è—Ü"}
        sub_name = sub_type_names.get(user.subscription_type, user.subscription_type)
        expires = user.subscription_expires.strftime('%d.%m.%Y %H:%M')
        profile_text += f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞: {sub_name} –¥–æ {expires}\n"
        user = await check_daily_limit_reset(user)
        profile_text += f"üîç –ü–æ–∏—Å–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è: {user.daily_searches_used}/12\n"
    else:
        profile_text += f"‚ùå –ü–æ–¥–ø–∏—Å–∫–∞: –ù–µ—Ç\n"
    
    profile_text += f"\nüìä *–°–¢–ê–¢–ò–°–¢–ò–ö–ê:*\n"
    profile_text += f"üîç –ü–æ–∏—Å–∫–æ–≤: {total_searches}\n"
    profile_text += f"‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {successful_searches}\n"
    profile_text += f"üë• –†–µ—Ñ–µ—Ä–∞–ª–æ–≤: {user.total_referrals}\n"
    profile_text += f"üìÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: {user.created_at.strftime('%d.%m.%Y')}\n\n"
    
    if user.is_admin:
        profile_text += f"üëë *–°—Ç–∞—Ç—É—Å:* –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†\n"
    
    await send_telegram_message(chat_id, profile_text, reply_markup=create_back_keyboard())

async def show_balance_menu(chat_id: int, user: User):
    """Show balance menu"""
    balance_text = f"üí∞ *–í–ê–® –ë–ê–õ–ê–ù–°*\n\n"
    balance_text += f"üí≥ *–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:* {user.balance:.2f} ‚ÇΩ\n"
    
    searches_available = int(user.balance // 25)
    balance_text += f"üîç *–î–æ—Å—Ç—É–ø–Ω–æ –ø–æ–∏—Å–∫–æ–≤:* {searches_available}\n\n"
    
    balance_text += f"üí° *–°–ü–û–°–û–ë–´ –ü–û–ü–û–õ–ù–ï–ù–ò–Ø:*\n"
    balance_text += f"ü§ñ –ö—Ä–∏–ø—Ç–æ–±–æ—Ç - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
    balance_text += f"‚≠ê –ó–≤–µ–∑–¥—ã Telegram - –º–≥–Ω–æ–≤–µ–Ω–Ω–æ\n\n"
    balance_text += f"üíé *–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ:* 100 ‚ÇΩ\n"
    balance_text += f"üîç *–û–¥–∏–Ω –ø–æ–∏—Å–∫:* 25 ‚ÇΩ\n\n"
    balance_text += f"üíº *–ò–ª–∏ –æ—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏!*"
    
    await send_telegram_message(chat_id, balance_text, reply_markup=create_balance_menu())

async def show_pricing_menu(chat_id: int, user: User):
    """Show pricing menu"""
    pricing_text = f"üõí *–¢–ê–†–ò–§–´ –ò –ü–û–î–ü–ò–°–ö–ò*\n\n"
    pricing_text += f"üíé *–†–ê–ó–û–í–´–ï –ü–û–ò–°–ö–ò:*\n"
    pricing_text += f"üîç 1 –ø–æ–∏—Å–∫ = 25 ‚ÇΩ\n\n"
    
    pricing_text += f"‚≠ê *–ü–û–î–ü–ò–°–ö–ò* (–º–∞–∫—Å. 12 –ø–æ–∏—Å–∫–æ–≤ –≤ –¥–µ–Ω—å):\n\n"
    
    pricing_text += f"üìÖ *1 –î–ï–ù–¨ - 149 ‚ÇΩ*\n"
    pricing_text += f"‚Ä¢ –î–æ 12 –ø–æ–∏—Å–∫–æ–≤ –≤ –¥–µ–Ω—å\n"
    pricing_text += f"‚Ä¢ –≠–∫–æ–Ω–æ–º–∏—è: 151 ‚ÇΩ\n\n"
    
    pricing_text += f"üìÖ *3 –î–ù–Ø - 299 ‚ÇΩ*\n"
    pricing_text += f"‚Ä¢ –î–æ 36 –ø–æ–∏—Å–∫–æ–≤ –∑–∞ 3 –¥–Ω—è\n"
    pricing_text += f"‚Ä¢ –≠–∫–æ–Ω–æ–º–∏—è: 601 ‚ÇΩ\n\n"
    
    pricing_text += f"üìÖ *1 –ú–ï–°–Ø–¶ - 1700 ‚ÇΩ*\n"
    pricing_text += f"‚Ä¢ –î–æ 360 –ø–æ–∏—Å–∫–æ–≤ –∑–∞ –º–µ—Å—è—Ü\n"
    pricing_text += f"‚Ä¢ –≠–∫–æ–Ω–æ–º–∏—è: 7300 ‚ÇΩ\n\n"
    
    pricing_text += f"üí° *–ü–æ–¥–ø–∏—Å–∫–∞ –≤—ã–≥–æ–¥–Ω–µ–µ —Ä–∞–∑–æ–≤—ã—Ö –ø–æ–∫—É–ø–æ–∫!*"
    
    await send_telegram_message(chat_id, pricing_text, reply_markup=create_pricing_menu())

async def show_referral_menu(chat_id: int, user: User):
    """Show referral menu"""
    referral_link = f"https://t.me/{BOT_USERNAME}?start={user.referral_code}"
    confirmed_referrals = await db.referrals.count_documents({"referrer_id": user.telegram_id, "confirmed": True})
    
    referral_text = f"üîó *–†–ï–§–ï–†–ê–õ–¨–ù–ê–Ø –ü–†–û–ì–†–ê–ú–ú–ê*\n\n"
    referral_text += f"üí∞ *–ó–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω–æ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞:* +25 ‚ÇΩ\n"
    referral_text += f"üìã *–£—Å–ª–æ–≤–∏–µ:* —Ä–µ—Ñ–µ—Ä–∞–ª –¥–æ–ª–∂–µ–Ω –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ @uzri_sebya\n\n"
    
    referral_text += f"üìä *–í–ê–®–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê:*\n"
    referral_text += f"üë• –í—Å–µ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–æ: {user.total_referrals}\n"
    referral_text += f"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {confirmed_referrals}\n"
    referral_text += f"üí∞ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {confirmed_referrals * 25} ‚ÇΩ\n\n"
    
    referral_text += f"üîó *–í–ê–®–ê –°–°–´–õ–ö–ê:*\n"
    referral_text += f"`{referral_link}`\n\n"
    
    referral_text += f"üì± *–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:*\n"
    referral_text += f"1. –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π\n"
    referral_text += f"2. –î—Ä—É–≥ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è\n"
    referral_text += f"3. –î—Ä—É–≥ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ @uzri_sebya\n"
    referral_text += f"4. –í–∞–º –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è 25 ‚ÇΩ"
    
    await send_telegram_message(chat_id, referral_text, reply_markup=create_back_keyboard())

async def show_help_menu(chat_id: int, user: User):
    """Show help menu"""
    help_text = f"‚ùì *–°–ü–†–ê–í–ö–ê –ò –ü–û–î–î–ï–†–ñ–ö–ê*\n\n"
    help_text += f"üéØ *–û –°–ï–†–í–ò–°–ï:*\n"
    help_text += f"–£–ó–†–ò –ø–æ–º–æ–≥–∞–µ—Ç –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª—é–¥—è—Ö –∏–∑ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.\n\n"
    
    help_text += f"üí∞ *–¢–ê–†–ò–§–´:*\n"
    help_text += f"üîç –†–∞–∑–æ–≤—ã–π –ø–æ–∏—Å–∫: 25 ‚ÇΩ\n"
    help_text += f"üìÖ –ü–æ–¥–ø–∏—Å–∫–∏: –æ—Ç 149 ‚ÇΩ/–¥–µ–Ω—å\n\n"
    
    help_text += f"üí≥ *–ü–û–ü–û–õ–ù–ï–ù–ò–ï:*\n"
    help_text += f"ü§ñ –ö—Ä–∏–ø—Ç–æ–±–æ—Ç\n"
    help_text += f"‚≠ê –ó–≤–µ–∑–¥—ã Telegram\n"
    help_text += f"üíé –ú–∏–Ω–∏–º—É–º: 100 ‚ÇΩ\n\n"
    
    help_text += f"üîó *–†–ï–§–ï–†–ê–õ–´:*\n"
    help_text += f"üí∞ 25 ‚ÇΩ –∑–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω–æ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞\n\n"
    
    help_text += f"üìû *–ü–û–î–î–ï–†–ñ–ö–ê:*\n"
    help_text += f"@Sigicara - —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n\n"
    
    help_text += f"‚öñÔ∏è *–í–ê–ñ–ù–û:*\n"
    help_text += f"–ü–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∏–∑—É—á–∏—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ —Å–µ—Ä–≤–∏—Å–∞"
    
    await send_telegram_message(chat_id, help_text, reply_markup=create_back_keyboard())

async def show_rules_menu(chat_id: int, user: User):
    """Show rules menu"""
    rules_text = f"üìã *–ü–†–ê–í–ò–õ–ê –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø –°–ï–†–í–ò–°–ê*\n\n"
    
    rules_text += f"*1. –°–û–ì–õ–ê–°–ò–ï –° –ü–†–ê–í–ò–õ–ê–ú–ò*\n"
    rules_text += f"–ò—Å–ø–æ–ª—å–∑—É—è –¥–∞–Ω–Ω—ã–π –±–æ—Ç, –≤—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–æ–≥–ª–∞—Å–∏–µ —Å–æ –≤—Å–µ–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏ —Å–µ—Ä–≤–∏—Å–∞.\n\n"
    
    rules_text += f"*2. –ù–ê–ó–ù–ê–ß–ï–ù–ò–ï –°–ï–†–í–ò–°–ê*\n"
    rules_text += f"‚Ä¢ –ü–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ–±–µ –≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–∞—Ö\n"
    rules_text += f"‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ç–µ—á–µ–∫ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö\n"
    rules_text += f"‚Ä¢ –ê–Ω–∞–ª–∏–∑ —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ —Å–ª–µ–¥–∞\n\n"
    
    rules_text += f"*3. –ó–ê–ü–†–ï–©–ê–ï–¢–°–Ø*\n"
    rules_text += f"‚Ä¢ –ü–æ–∏—Å–∫ –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ —Å–æ–≥–ª–∞—Å–∏—è –≤–ª–∞–¥–µ–ª—å—Ü–∞\n"
    rules_text += f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–∞\n"
    rules_text += f"‚Ä¢ –ù–∞—Ä—É—à–µ–Ω–∏–µ –∑–∞–∫–æ–Ω–æ–≤ –†–§\n"
    rules_text += f"‚Ä¢ –ü—Ä–æ–¥–∞–∂–∞ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏\n"
    rules_text += f"‚Ä¢ –ü—Ä–µ—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∏ —à–∞–Ω—Ç–∞–∂\n\n"
    
    rules_text += f"*4. –¢–ê–†–ò–§–ò–ö–ê–¶–ò–Ø*\n"
    rules_text += f"‚Ä¢ –†–∞–∑–æ–≤—ã–π –ø–æ–∏—Å–∫: 25 ‚ÇΩ\n"
    rules_text += f"‚Ä¢ –ü–æ–¥–ø–∏—Å–∫–∏ —Å –ª–∏–º–∏—Ç–æ–º 12 –ø–æ–∏—Å–∫–æ–≤/–¥–µ–Ω—å\n"
    rules_text += f"‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ: 100 ‚ÇΩ\n"
    rules_text += f"‚Ä¢ –í–æ–∑–≤—Ä–∞—Ç —Å—Ä–µ–¥—Å—Ç–≤ –Ω–µ –ø—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω\n\n"
    
    rules_text += f"*5. –û–¢–í–ï–¢–°–¢–í–ï–ù–ù–û–°–¢–¨*\n"
    rules_text += f"‚Ä¢ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ –Ω–µ—Å–µ—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n"
    rules_text += f"‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ —Å–≤–æ–∏ –¥–µ–π—Å—Ç–≤–∏—è\n"
    rules_text += f"‚Ä¢ –ü—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª - –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–∞\n\n"
    
    rules_text += f"*6. –¢–ï–•–ù–ò–ß–ï–°–ö–ê–Ø –ü–û–î–î–ï–†–ñ–ö–ê*\n"
    rules_text += f"@Sigicara - —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n\n"
    
    rules_text += f"‚öñÔ∏è *–ò—Å–ø–æ–ª—å–∑—É—è —Å–µ—Ä–≤–∏—Å, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–æ–≥–ª–∞—Å–∏–µ —Å –¥–∞–Ω–Ω—ã–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏.*"
    
    await send_telegram_message(chat_id, rules_text, reply_markup=create_back_keyboard())

async def handle_admin_callback(chat_id: int, user: User, data: str):
    """Handle admin callbacks"""
    if data == "admin_panel":
        admin_text = f"üëë *–ê–î–ú–ò–ù-–ü–ê–ù–ï–õ–¨*\n\n"
        admin_text += f"üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–æ–º –£–ó–†–ò\n\n"
        admin_text += f"üíé *–ù–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å* - –¥–æ–±–∞–≤–∏—Ç—å –¥–µ–Ω—å–≥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n"
        admin_text += f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞* - –æ–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–∏—Å–∞\n"
        admin_text += f"üë• *–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏* - —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
        admin_text += f"üí≥ *–ü–ª–∞—Ç–µ–∂–∏* - –∏—Å—Ç–æ—Ä–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π"
        
        await send_telegram_message(chat_id, admin_text, reply_markup=create_admin_menu())
    
    elif data == "admin_add_balance":
        await send_telegram_message(
            chat_id,
            "üíé *–ù–ê–ß–ò–°–õ–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê*\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n`ID –°–£–ú–ú–ê`\n\n–ü—Ä–∏–º–µ—Ä: `123456789 100`",
            reply_markup=create_back_keyboard()
        )
    
    elif data == "admin_stats":
        total_users = await db.users.count_documents({})
        total_searches = await db.searches.count_documents({})
        total_revenue = await db.searches.aggregate([
            {"$group": {"_id": None, "total": {"$sum": "$cost"}}}
        ]).to_list(1)
        active_subs = await db.users.count_documents({"subscription_expires": {"$gt": datetime.utcnow()}})
        
        stats_text = f"üìä *–°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ï–†–í–ò–°–ê*\n\n"
        stats_text += f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\n"
        stats_text += f"üîç –ü–æ–∏—Å–∫–æ–≤: {total_searches}\n"
        stats_text += f"‚≠ê –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫: {active_subs}\n"
        revenue = total_revenue[0]['total'] if total_revenue else 0
        stats_text += f"üí∞ –í—ã—Ä—É—á–∫–∞: {revenue:.2f} ‚ÇΩ"
        
        await send_telegram_message(chat_id, stats_text, reply_markup=create_admin_menu())

async def handle_payment_callback(chat_id: int, user: User, data: str):
    """Handle payment callbacks"""
    if data == "pay_crypto":
        await send_telegram_message(
            chat_id,
            "ü§ñ *–ü–û–ü–û–õ–ù–ï–ù–ò–ï –ß–ï–†–ï–ó –ö–†–ò–ü–¢–û–ë–û–¢*\n\nüí° –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∫–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–≤–µ–∑–¥–∞–º–∏",
            reply_markup=create_back_keyboard()
        )
    
    elif data == "pay_stars":
        await send_telegram_message(
            chat_id,
            "‚≠ê *–ü–û–ü–û–õ–ù–ï–ù–ò–ï –ó–í–ï–ó–î–ê–ú–ò*\n\nüí° –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ\n\n–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –ø–æ–¥–¥–µ—Ä–∂–∫–µ @Sigicara",
            reply_markup=create_back_keyboard()
        )
    
    elif data == "buy_single_search":
        if user.balance >= 25.0:
            await send_telegram_message(
                chat_id,
                "‚úÖ *–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å —Å—Ä–µ–¥—Å—Ç–≤–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞*\n\nüîç –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª '–ü–æ–∏—Å–∫'",
                reply_markup=create_back_keyboard()
            )
        else:
            needed = 25.0 - user.balance
            await send_telegram_message(
                chat_id,
                f"üí≥ *–ü–û–ö–£–ü–ö–ê –ü–û–ò–°–ö–ê*\n\nüíé –ù—É–∂–Ω–æ –¥–æ–ø–ª–∞—Ç–∏—Ç—å: {needed:.2f} ‚ÇΩ\n\nüí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –Ω–∞ —Å—É–º–º—É –æ—Ç 100 ‚ÇΩ",
                reply_markup=create_balance_menu()
            )

async def handle_purchase_callback(chat_id: int, user: User, data: str):
    """Handle subscription purchase callbacks"""
    prices = {
        "buy_day_sub": (149.0, "day", 1),
        "buy_3days_sub": (299.0, "3days", 3),
        "buy_month_sub": (1700.0, "month", 30)
    }
    
    if data in prices:
        price, sub_type, days = prices[data]
        
        if user.balance >= price:
            # Purchase subscription
            expires = datetime.utcnow() + timedelta(days=days)
            
            await db.users.update_one(
                {"telegram_id": user.telegram_id},
                {
                    "$set": {
                        "subscription_type": sub_type,
                        "subscription_expires": expires,
                        "daily_searches_used": 0,
                        "daily_searches_reset": datetime.utcnow()
                    },
                    "$inc": {"balance": -price}
                }
            )
            
            sub_names = {"day": "1 –¥–µ–Ω—å", "3days": "3 –¥–Ω—è", "month": "1 –º–µ—Å—è—Ü"}
            await send_telegram_message(
                chat_id,
                f"üéâ *–ü–û–î–ü–ò–°–ö–ê –û–§–û–†–ú–õ–ï–ù–ê!*\n\n‚≠ê –¢–∞—Ä–∏—Ñ: {sub_names[sub_type]}\nüí∞ –°–ø–∏—Å–∞–Ω–æ: {price} ‚ÇΩ\nüìÖ –î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: {expires.strftime('%d.%m.%Y %H:%M')}\n\nüîç –î–æ—Å—Ç—É–ø–Ω–æ –¥–æ 12 –ø–æ–∏—Å–∫–æ–≤ –≤ –¥–µ–Ω—å!",
                reply_markup=create_main_menu()
            )
        else:
            needed = price - user.balance
            await send_telegram_message(
                chat_id,
                f"‚ùå *–ù–ï–î–û–°–¢–ê–¢–û–ß–ù–û –°–†–ï–î–°–¢–í*\n\nüí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance:.2f} ‚ÇΩ\nüíé –ù—É–∂–Ω–æ: {price} ‚ÇΩ\nüìà –î–æ–ø–ª–∞—Ç–∏—Ç—å: {needed:.2f} ‚ÇΩ",
                reply_markup=create_balance_menu()
            )

async def handle_telegram_update(update_data: Dict[str, Any]):
    """Process incoming Telegram update"""
    callback_query = update_data.get('callback_query')
    if callback_query:
        await handle_callback_query(callback_query)
        return
    
    message = update_data.get('message')
    if not message:
        return

    chat_id = message.get('chat', {}).get('id')
    text = message.get('text', '')
    user_info = message.get('from', {})
    
    if not chat_id:
        return

    user = await get_or_create_user(
        telegram_id=user_info.get('id', chat_id),
        username=user_info.get('username'),
        first_name=user_info.get('first_name'),
        last_name=user_info.get('last_name')
    )

    # Handle /start command
    if text.startswith('/start'):
        parts = text.split()
        if len(parts) > 1:
            referral_code = parts[1]
            await process_referral(user.telegram_id, referral_code)
        
        if not user.is_admin:
            is_subscribed = await check_subscription(user.telegram_id)
            if not is_subscribed:
                await send_telegram_message(
                    chat_id,
                    f"üéØ *–î–û–ë–†–û –ü–û–ñ–ê–õ–û–í–ê–¢–¨ –í –£–ó–†–ò!*\n\nüîí *–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @uzri_sebya*",
                    reply_markup=create_subscription_keyboard()
                )
                return
        
        await show_main_menu(chat_id, user)
    
    # Handle admin balance commands
    elif user.is_admin and ' ' in text and text.split()[0].isdigit():
        parts = text.split()
        if len(parts) == 2:
            try:
                target_id = int(parts[0])
                amount = float(parts[1])
                
                result = await db.users.update_one(
                    {"telegram_id": target_id},
                    {"$inc": {"balance": amount}}
                )
                
                if result.modified_count > 0:
                    await send_telegram_message(
                        chat_id,
                        f"‚úÖ *–ë–∞–ª–∞–Ω—Å –Ω–∞—á–∏—Å–ª–µ–Ω*\n\nüë§ ID: {target_id}\nüí∞ –°—É–º–º–∞: {amount} ‚ÇΩ"
                    )
                    
                    await send_telegram_message(
                        target_id,
                        f"üéÅ *–ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞*\n\nüí∞ –ù–∞ –≤–∞—à —Å—á–µ—Ç –∑–∞—á–∏—Å–ª–µ–Ω–æ: {amount} ‚ÇΩ\n\nüí° –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–µ—Ä–≤–∏—Å–æ–º!"
                    )
                else:
                    await send_telegram_message(chat_id, "‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            except:
                await send_telegram_message(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã")
    
    # Handle search queries
    else:
        await handle_search_query(chat_id, text, user)

async def handle_search_query(chat_id: int, query: str, user: User):
    """Handle search query"""
    if not user.is_admin:
        is_subscribed = await check_subscription(user.telegram_id)
        if not is_subscribed:
            await send_telegram_message(
                chat_id,
                "üîí –î–ª—è –ø–æ–∏—Å–∫–∞ –Ω—É–∂–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ @uzri_sebya",
                reply_markup=create_subscription_keyboard()
            )
            return
    
    can_search_result, payment_method = await can_search(user)
    
    if not can_search_result and not user.is_admin:
        if "–ø—Ä–µ–≤—ã—à–µ–Ω –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç" in payment_method:
            await send_telegram_message(
                chat_id,
                "‚è∞ *–î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω*\n\n–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –≤—Å–µ 12 –ø–æ–∏—Å–∫–æ–≤ –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è",
                reply_markup=create_main_menu()
            )
        else:
            await send_telegram_message(
                chat_id,
                f"üí∞ *–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤*\n\n–î–ª—è –ø–æ–∏—Å–∫–∞ –Ω—É–∂–Ω–æ 25 ‚ÇΩ\n–í–∞—à –±–∞–ª–∞–Ω—Å: {user.balance:.2f} ‚ÇΩ",
                reply_markup=create_balance_menu()
            )
        return
    
    search_type = detect_search_type(query)
    
    await send_telegram_message(
        chat_id,
        f"üîç *–í—ã–ø–æ–ª–Ω—è—é –ø–æ–∏—Å–∫...*\n{search_type}\n‚è±Ô∏è –ü–æ–¥–æ–∂–¥–∏—Ç–µ..."
    )
    
    try:
        results = await usersbox_request("/search", {"q": query})
        
        formatted_results = format_search_results(results, query, search_type)
        await send_telegram_message(chat_id, formatted_results, reply_markup=create_main_menu())
        
        # Process payment and save search
        cost = 0.0
        if not user.is_admin:
            if await has_active_subscription(user):
                await db.users.update_one(
                    {"telegram_id": user.telegram_id},
                    {"$inc": {"daily_searches_used": 1}}
                )
                payment_method = "subscription"
            else:
                cost = 25.0
                await db.users.update_one(
                    {"telegram_id": user.telegram_id},
                    {"$inc": {"balance": -25.0}}
                )
                payment_method = "balance"
        
        search = Search(
            user_id=user.telegram_id,
            query=query,
            search_type=search_type,
            results=results,
            success=results.get('status') == 'success',
            cost=cost,
            payment_method=payment_method
        )
        await db.searches.insert_one(search.dict())
    
    except Exception as e:
        await send_telegram_message(
            chat_id,
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø–æ–∏—Å–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=create_main_menu()
        )

async def process_referral(referred_user_id: int, referral_code: str) -> bool:
    """Process referral"""
    try:
        referrer = await db.users.find_one({"referral_code": referral_code})
        if not referrer or referrer['telegram_id'] == referred_user_id:
            return False

        existing_referral = await db.referrals.find_one({
            "referrer_id": referrer['telegram_id'],
            "referred_id": referred_user_id
        })
        if existing_referral:
            return False

        referral = Referral(
            referrer_id=referrer['telegram_id'],
            referred_id=referred_user_id,
            confirmed=False
        )
        await db.referrals.insert_one(referral.dict())

        await db.users.update_one(
            {"telegram_id": referrer['telegram_id']},
            {"$inc": {"total_referrals": 1}}
        )

        await send_telegram_message(
            referrer['telegram_id'],
            f"üë• *–ù–æ–≤—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª!*\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–µ—Ä–µ—à–µ–ª –ø–æ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–µ\nüí∞ 25 ‚ÇΩ –±—É–¥–µ—Ç –Ω–∞—á–∏—Å–ª–µ–Ω–æ –ø–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª"
        )

        return True
    except Exception as e:
        logging.error(f"Referral processing error: {e}")
        return False

# API endpoints
@api_router.get("/users")
async def get_users():
    """Get all users"""
    users = await db.users.find().to_list(1000)
    for user in users:
        user["_id"] = str(user["_id"])
    return users

@api_router.get("/stats")
async def get_stats():
    """Get bot statistics"""
    total_users = await db.users.count_documents({})
    total_searches = await db.searches.count_documents({})
    total_referrals = await db.referrals.count_documents({})
    active_subs = await db.users.count_documents({"subscription_expires": {"$gt": datetime.utcnow()}})

    return {
        "total_users": total_users,
        "total_searches": total_searches,
        "total_referrals": total_referrals,
        "active_subscriptions": active_subs
    }

# Include the router in the main app
app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()